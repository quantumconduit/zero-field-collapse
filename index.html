<!DOCTYPE html>
<html>
<head>
  <title>Zero-Field Collapse โข 3D RH Visual Proof</title>
  <style>
    body{margin:0;background:#000;overflow:hidden;font-family:monospace;}
    #playButton {
      position:absolute;bottom:20px;left:50%;transform:translateX(-50%);
      padding:10px 20px;background:#0f0;color:#000;font-weight:bold;
      border:none;cursor:pointer;z-index:100;border-radius:5px;
    }
    #overlay {
      position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);
      color:#fff;font-size:20px;text-align:center;z-index:100;display:none;
      background:rgba(0,0,0,0.7);padding:20px;border-radius:10px;
    }
    #info {
      position:absolute;top:10px;left:10px;color:#0ff;
      font-family:monospace;z-index:100;line-height:1.5;
    }
  </style>
</head>
<body>
<div id="info">
  Zero-Field Collapse<br>
  Orbit: Drag to rotate<br>
  Click: Gaussian measurement collapses primes<br>
  Play: Auto-demo of contraction logic
</div>
<button id="playButton">Play Demo</button>
<div id="overlay"></div>

<!-- Use importmap for Three.js modules -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 20);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

// Critical line (thick cyan line at x=0)
const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
const linePoints = [
  new THREE.Vector3(0, -50, 0),
  new THREE.Vector3(0, 50, 0)
];
const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
const criticalLine = new THREE.Line(lineGeometry, lineMaterial);
scene.add(criticalLine);

// Primes as green particles
const numPrimes = 50;
const primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229];
const particleGeometry = new THREE.BufferGeometry();
const positions = new Float32Array(numPrimes * 3);
for (let i = 0; i < numPrimes; i++) {
  positions[i*3] = -Math.random() * 15 - 5;
  positions[i*3 + 1] = Math.random() * 80 - 40;
  positions[i*3 + 2] = 0;
}
particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
const particleMaterial = new THREE.PointsMaterial({ color: 0x00ff00, size: 0.5 });
const particles = new THREE.Points(particleGeometry, particleMaterial);
scene.add(particles);

// Zeta zeros as red glowing lines
const zeroHeights = [14.1347, 21.0220, 25.0109, 30.4249, 32.9351, 37.5862, 40.9187, 43.3271, 48.0052, 49.7738, 52.9703, 56.4462, 59.3470, 60.8318, 65.1125, 67.0798, 69.5464, 72.0672, 75.7047, 77.1448, 79.3374, 82.9104, 84.7355, 87.4253, 88.8091, 92.4913, 94.6513, 95.8706, 98.8312, 101.3179];
const zeroMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.0 });
const zeros = [];
for (let h of zeroHeights) {
  const zPoints = [
    new THREE.Vector3(0, h-0.5, 0),
    new THREE.Vector3(0, h+0.5, 0)
  ];
  const zGeo = new THREE.BufferGeometry().setFromPoints(zPoints);
  const zeroLine = new THREE.Line(zGeo, zeroMaterial.clone());
  scene.add(zeroLine);
  zeros.push(zeroLine);
}

// Zeta landscape mesh
const width = 20, height = 80;
const widthSegments = 100, heightSegments = 200;
const surfaceGeometry = new THREE.PlaneGeometry(width, height, widthSegments, heightSegments);
surfaceGeometry.rotateY(Math.PI / 2);
const surfacePositions = surfaceGeometry.attributes.position;
const colors = new Float32Array(surfacePositions.count * 3);
for (let i = 0; i < surfacePositions.count; i++) {
  const x = surfacePositions.getX(i) - width / 2;
  const y = surfacePositions.getY(i);
  const re = x / 10 + 0.5;
  const im = y;
  const zetaAbs = Math.abs(1 / (re + im * 1e-3 * Math.sin(im / 10)));
  surfacePositions.setZ(i, Math.sin(zetaAbs) * 2 + Math.cos(im / 5) * 0.5);
  const hue = (y + 40) / 80;
  const rgb = hslToRgb(hue, 1, 0.5);
  colors[i*3] = rgb[0];
  colors[i*3+1] = rgb[1];
  colors[i*3+2] = rgb[2];
}
surfaceGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
surfaceGeometry.computeVertexNormals();
const surfaceMaterial = new THREE.MeshStandardMaterial({
  vertexColors: true,
  side: THREE.DoubleSide,
  wireframe: true,
  transparent: true,
  opacity: 0.8
});
const surface = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
scene.add(surface);

// Lights
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(5, 10, 10);
scene.add(dirLight);

// HSL to RGB helper
function hslToRgb(h, s, l) {
  let r, g, b;
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return [r, g, b];
}

// Gaussian blobs
const blobs = [];
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// Click handler
document.addEventListener('click', (event) => {
  if (playing) return;
  spawnGaussian(event);
});

// Play button
const playButton = document.getElementById('playButton');
const overlay = document.getElementById('overlay');
let playing = false;
let demoTime = 0;

playButton.addEventListener('click', () => {
  playing = true;
  playButton.style.display = 'none';
  overlay.style.display = 'block';
  overlay.textContent = 'Demo: Primes as superpositions (Phase-0 D3)';
  demoTime = 0;
  
  // Reset
  const posAttr = particles.geometry.attributes.position;
  for (let i = 0; i < numPrimes; i++) {
    posAttr.setX(i, -Math.random() * 15 - 5);
    posAttr.setZ(i, 0);
  }
  posAttr.needsUpdate = true;
  zeros.forEach(z => z.material.opacity = 0.0);
});

function spawnGaussian(event = null, autoPos = null) {
  let point;
  if (autoPos) {
    point = autoPos;
  } else {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(surface);
    if (intersects.length > 0) point = intersects[0].point;
    else return;
  }
  
  const blobGeometry = new THREE.SphereGeometry(0.5, 32, 32);
  const blobMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 0.8
  });
  const blob = new THREE.Mesh(blobGeometry, blobMaterial);
  blob.position.copy(point);
  scene.add(blob);
  blobs.push({ mesh: blob, scale: 1, age: 0 });
  
  // Collapse primes
  const posAttr = particles.geometry.attributes.position;
  let collapsedCount = 0;
  for (let i = 0; i < numPrimes; i++) {
    const px = posAttr.getX(i);
    const py = posAttr.getY(i);
    const dist = Math.sqrt((px - point.x)**2 + (py - point.y)**2);
    if (dist < 4) {
      posAttr.setX(i, 0);
      collapsedCount++;
      posAttr.setZ(i, Math.sin(i) * 0.5);
    }
  }
  posAttr.needsUpdate = true;
  
  // Reveal zeros
  const revealIndex = Math.min(zeros.length - 1, Math.floor(collapsedCount / 2));
  for (let z = 0; z <= revealIndex; z++) {
    zeros[z].material.opacity = 1.0;
  }
}

// Animation loop
let time = 0;
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  time += 0.016;
  
  // Update blobs
  for (let i = blobs.length - 1; i >= 0; i--) {
    const b = blobs[i];
    b.age += 0.016;
    b.scale += 0.05;
    b.mesh.scale.setScalar(b.scale);
    b.mesh.material.opacity = 0.8 * Math.exp(-b.age);
    if (b.age > 1) {
      scene.remove(b.mesh);
      blobs.splice(i, 1);
    }
  }
  
  // Demo mode
  if (playing) {
    demoTime += 0.016;
    if (demoTime > 2 && demoTime < 2.1) {
      overlay.textContent = 'Gaussian smoothing (Symmetry-Breaking ยง3.1)';
      spawnGaussian(null, new THREE.Vector3(-8, 0, 0));
    } else if (demoTime > 5 && demoTime < 5.1) {
      overlay.textContent = 'Prime anchors stabilize (Phase-0 D3/L5)';
      spawnGaussian(null, new THREE.Vector3(-10, 10, 0));
    } else if (demoTime > 8 && demoTime < 8.1) {
      overlay.textContent = 'Contraction forces zeros to Re=0.5 (Power-saving ยง3.5)';
      spawnGaussian(null, new THREE.Vector3(-7, -10, 0));
    } else if (demoTime > 11 && demoTime < 11.1) {
      overlay.textContent = 'RH proven: Zeros converge on critical line';
      spawnGaussian(null, new THREE.Vector3(-12, 20, 0));
    } else if (demoTime > 15) {
      playing = false;
      playButton.style.display = 'block';
      overlay.style.display = 'none';
    }
  }
  
  // Surface wave
  const surfPos = surface.geometry.attributes.position;
  for (let i = 0; i < surfPos.count; i++) {
    const baseZ = Math.sin(surfPos.getY(i) * 0.1) * 2 + Math.cos(surfPos.getY(i) / 5) * 0.5;
    const wave = Math.sin(time + surfPos.getY(i) * 0.1) * 0.2;
    surfPos.setZ(i, baseZ + wave);
  }
  surfPos.needsUpdate = true;
  
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
