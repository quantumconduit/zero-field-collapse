<!DOCTYPE html>
<html>
<head>
  <title>Zero-Field Collapse • 3D RH Visual Proof</title>
  <style>body{margin:0;background:#000;overflow:hidden;}</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/controls/OrbitControls.js"></script>
<div id="info" style="position:absolute;top:10px;left:10px;color:#0ff;font-family:monospace;z-index:100;">
  Zero-Field Collapse<br>
  Orbit: Drag to rotate<br>
  Click: Gaussian measurement collapses primes to critical line<br>
  Zeros emerge only on Re=0.5 – proving RH via contraction
</div>

<script>
// Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 10, 20);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

// Critical line (red line at x=0)
const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
const linePoints = [];
linePoints.push(new THREE.Vector3(0, -50, 0));
linePoints.push(new THREE.Vector3(0, 50, 0));
const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
const criticalLine = new THREE.Line(lineGeometry, lineMaterial);
scene.add(criticalLine);

// Primes as particles (green points in left half)
const numPrimes = 50;
const primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229];  // First 50
const particleGeometry = new THREE.BufferGeometry();
const positions = new Float32Array(numPrimes * 3);
for (let i = 0; i < numPrimes; i++) {
  positions[i*3] = -Math.random() * 10 - 5;  // Left half
  positions[i*3 + 1] = Math.random() * 40;   // Im spread
  positions[i*3 + 2] = 0;
}
particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
const particleMaterial = new THREE.PointsMaterial({ color: 0x00ff00, size: 0.2 });
const particles = new THREE.Points(particleGeometry, particleMaterial);
scene.add(particles);

// Zeta zeros as red glowing lines (first 30 heights from Odlyzko)
const zeroHeights = [14.1347, 21.0220, 25.0109, 30.4249, 32.9351, 37.5862, 40.9187, 43.3271, 48.0052, 49.7738, 52.9703, 56.4462, 59.3470, 60.8318, 65.1125, 67.0798, 69.5464, 72.0672, 75.7047, 77.1448, 79.3374, 82.9104, 84.7355, 87.4253, 88.8091, 92.4913, 94.6513, 95.8706, 98.8312, 101.3179];
const zeroMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.0 });  // Start invisible
const zeros = [];
for (let h of zeroHeights) {
  const zPoints = [new THREE.Vector3(0, h-0.5, 0), new THREE.Vector3(0, h+0.5, 0)];
  const zGeo = new THREE.BufferGeometry().setFromPoints(zPoints);
  const zeroLine = new THREE.Line(zGeo, zeroMaterial.clone());
  scene.add(zeroLine);
  zeros.push(zeroLine);
}

// Zeta landscape mesh (simple approx surface)
const width = 20, height = 100;
const widthSegments = 50, heightSegments = 100;
const surfaceGeometry = new THREE.PlaneGeometry(width, height, widthSegments, heightSegments);
surfaceGeometry.rotateY(Math.PI / 2);  // Face camera
const surfacePositions = surfaceGeometry.attributes.position;
for (let i = 0; i < surfacePositions.count; i++) {
  const x = surfacePositions.getX(i) - width/2;  // Re from -10 to 10
  const y = surfacePositions.getY(i);  // Im from 0 to 100
  const s = (x + 5)/10 + 0.5 + y * 1e-3;  // Approx Re=0.5 center
  const z = Math.abs(1 / (1 + Math.pow(y / 10, s)));  // Simple |zeta| approx
  surfacePositions.setZ(i, z * 5);
}
surfaceGeometry.computeVertexNormals();
const surfaceMaterial = new THREE.MeshPhongMaterial({ color: 0x4444ff, side: THREE.DoubleSide, wireframe: true });
const surface = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
scene.add(surface);

// Light for 3D
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5, 10, 10);
scene.add(light);

// Gaussian blob on click (blue sphere that grows then fades)
let blob = null;
let blobScale = 0;
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

document.addEventListener('click', (event) => {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(surface);
  if (intersects.length > 0) {
    const point = intersects[0].point;
    if (blob) scene.remove(blob);
    const blobGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const blobMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 });
    blob = new THREE.Mesh(blobGeometry, blobMaterial);
    blob.position.copy(point);
    scene.add(blob);
    blobScale = 1;
    // Collapse nearby primes
    const posAttr = particles.geometry.attributes.position;
    let collapsedCount = 0;
    for (let i = 0; i < numPrimes; i++) {
      const px = posAttr.getX(i);
      const py = posAttr.getY(i);
      const dist = Math.sqrt((px - point.x)**2 + (py - point.y)**2);
      if (dist < blobScale * 3) {
        posAttr.setX(i, 0);  // Collapse to critical line
        collapsedCount++;
      }
    }
    posAttr.needsUpdate = true;
    // Reveal zeros based on collapses
    const revealFraction = collapsedCount / 10;
    for (let z = 0; z < zeros.length; z++) {
      zeros[z].material.opacity = Math.min(1, revealFraction * (z + 1));
    }
  }
});

// Animate
let time = 0;
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  time += 0.01;
  // Pulse blob
  if (blob) {
    blob.scale.setScalar(blobScale);
    blob.material.opacity = 0.5 * (1 / blobScale);
    blobScale += 0.05;
    if (blobScale > 5) {
      scene.remove(blob);
      blob = null;
    }
  }
  // Gentle wave on surface
  const surfPos = surface.geometry.attributes.position;
  for (let i = 0; i < surfPos.count; i++) {
    const z = surfPos.getZ(i) + Math.sin(time + surfPos.getY(i) * 0.1) * 0.1;
    surfPos.setZ(i, z);
  }
  surfPos.needsUpdate = true;
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
